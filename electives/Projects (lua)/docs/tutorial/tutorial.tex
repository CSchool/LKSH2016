\section{Lua за 15 минут}

\lstset{style=Lua}

Данное пособие является адаптацией статьи ``Learn Lua in 15 Minutes'' с некоторыми дополнениями. 
Оригинал на английском языке можно найти по адресу: \url{http://tylerneylon.com/a/learn-lua/}.

\subsection{Комментарии}

Комментарии в Lua можно сделать двумя способами:

\begin{lstlisting}
-- One line comment
	
--[[
    first line
    seconde line
--]]
\end{lstlisting}

Первый способ начинает однострочный комментарий, второй~---~многострочный.

\subsection{Переменные (простые типы)}

Все числовые переменные являются вещественными (double):

\begin{lstlisting}
number = 42
another_number = 3.1415
\end{lstlisting}

Над числами можно проводить следующие операции: сложение (\lstinline{+}), вычитание (\lstinline{-}), 
умножение (\lstinline{*}), деление (\lstinline{/}), возведение в  степень (\lstinline{^}):

\begin{lstlisting}
add = 5 + 3 -- add = 8
sub = add - 4 -- sub = 4
mult = add * sub -- mult = 32
div = add / sub -- div = 2
pow = 2^3 -- pow = 8
\end{lstlisting}

Строки в языка Lua являются \emph{неизменяемыми}, то есть нельзя обратиться к индексу строки и поменять символ.
Объявление сток можно сделать тремя способами:

\begin{lstlisting}
color = 'black'
season = "summer"
huge_string = [[ This is
	a very-very
	long string! ]]
\end{lstlisting}

Для соединения строк (\emph{конкатенация} строк) используется оператор $..$:

\begin{lstlisting}
name = "Petr"
surname = "Ivanov"
pupil = name .. " " .. surname -- pupil = "Petr Ivanov"
\end{lstlisting}

Если при конкатенации строк будут использоваться числовые переменные, то они автоматически будут приведены к строкам:

\begin{lstlisting}
number = 42
question = number .. " is good answer for everything!"
-- question = "42 is good answer for everything!"
\end{lstlisting}

Переменные могут принимать логическое значение \emph{boolean}: \textbf{true} (истина) или \textbf{ложь}:

\begin{lstlisting}
to_be_or_not_to_be = true
\end{lstlisting}

Переменные также могут принимать значение \emph{nil}. Данный тип означает, что значения у переменной \textbf{не существует}!

\begin{lstlisting}
aliens_exist = nil
\end{lstlisting}

\subsection{Логические операторы}

Существуют следующие логические операторы: \lstinline{and}, \lstinline{or} и \lstinline{not}.
Все логические операторы предполагают, что \lstinline{false} и \lstinline{nil} представляют собой значение \textbf{false}, 
а все остальные значения~---~\textbf{true}.

Оператор \lstinline{and} возвращает первый аргумент в том случае, если его значение \emph{false}, 
в противном случае возвращается второй аргумент.
Оператор \lstinline{or} возвращает  первый аргумент в том случае, если его значение \emph{true},
в противном случае возвращается второй аргумент.

\begin{lstlisting}
print(4 and 5)         -- 5
print(nil and 13)      -- nil
print(false and 13)    -- false
print(4 or 5)          -- 4
print(false or 5)      -- 5
\end{lstlisting}

Операторы \lstinline{and} и \lstinline{or} не вычисляют второй аргумент, если в это нет необходимости.
Например, выражение \lstinline{x = x or v} эквивалентно следующему выражению:

\begin{lstlisting}
if not x then x = v end
\end{lstlisting}

То есть, если значение \lstinline{x} не существует, то ставится значение \lstinline{v}.

Ещё один вариант использования условных операторов: реализация тернарного оператора (\lstinline{a ? b : c}). В языке Lua его можно реализовать следующим способом:

\begin{lstlisting}
a and b or c -- (a and b) or c
\end{lstlisting}

Пример выбора максимального значения из двух чисел:

\begin{lstlisting}
max = (x > y) and x or y
\end{lstlisting}

Сперва вычисляется выражение \lstinline{x > y}. Если оно имеет значение \lstinline{true}, то срабатывает \lstinline{(x > y)    and x} и возвращается \lstinline{x}, так как \lstinline{x}~---~число и всегда равен значению \lstinline{true}. 
Если же выражение  \lstinline{x > y} имеет значение \lstinline{false}, 
то выражение \lstinline{(x > y)   and x} возвращает \lstinline{false}, оно сравнивается с \lstinline{y}, 
и оператор \lstinline{or} возвращает значение \lstinline{y}.

Оператор \lstinline{not} всегда возвращает \lstinline{true} или \lstinline{false}:

\begin{lstlisting}
print(not nil)      -- true
print(not false)    -- true
print(not 0)        -- false
print(not not nil)  -- false
\end{lstlisting}

\subsection{Операторы отношений}

В языке Lua выделяются следующие операторы отношений, каждый из которых возвращает \lstinline{true} или \lstinline{false}:

\begin{lstlisting}
<   >   <=  >=  ==  ~=
\end{lstlisting}

Оператор $==$ проверяет равенство аргументов, а оператор \lstinline{~=}~---~неравенство:

\begin{lstlisting}
print(5 == 6) -- false
print(52 ~= 0) -- true
\end{lstlisting}

\subsection{Условный оператор if}

Условия в языке Lua записываются при помощи условного оператора \lstinline{if}:

\begin{lstlisting}
if statement then
... -- do something if statement == true
end
\end{lstlisting}

Оператор проверяет условие \emph{statement} и выполняет операции между ключевыми словами \lstinline{then} и \lstinline{end} только в том случае, если \emph{statement}~---~истинен.

Примеры условий:

\begin{lstlisting}
if a < 0 then a = 0 end

if object == "car" then
  print("This is car!")
end
\end{lstlisting}

Можно задавать поведение условного оператора \lstinline{if} при помощи ключевого слова \lstinline{else}, в случае, если условие \emph{statement}~---~ложно:

\begin{lstlisting}
if statement then
... -- statement == true
else
... -- statement == false
end
\end{lstlisting}

Пример использования:

\begin{lstlisting}
if age < 18 then
  print("You can't go to this movie!")
else
  print("Your age is allowed for this movie")
end
\end{lstlisting}

Иногда могут понадобится для работы множественные ветвления (\lstinline{elseif}) условного оператора \lstinline{if}:

\begin{lstlisting}
if op == "+" then
  r = a + b
elseif op == "-" then
  r = a - b
elseif op == "*" then
  r = a*b
elseif op == "/" then
  r = a/b
else
  print("Error!")
end
\end{lstlisting}

Отрицание логического выражения \emph{statement} задается при помощи ключевого слова \lstinline{not}:

\begin{lstlisting}
if not end_of_game then ... end
\end{lstlisting}

Выражение \emph{statement} может содержать в себе сложные логические выражения:

\begin{lstlisting}
if age >= 14 and age <= 18 then ... end
\end{lstlisting}

\subsection{Циклы}

Циклы~---~это управляющая конструкция, которая позволяет многократно исполнять ряд инструкций.

\subsubsection{While}

Цикл с предусловием (\lstinline{while})~---~это цикл, который будет выполняться, пока истинно условие (\lstinline{true}). То есть если условие истинно, цикл выполняется, иначе он заканчивает свою работу и управление передается коду за ним. 

\begin{lstlisting}
num = 0
while num < 3 do
  num = num + 1;
  print(num);
end     
\end{lstlisting}

В результате будет выведено: 
\\* 1 
\\* 2
\\* 3

\subsubsection{Repeat}

Цикл с предусловием (\lstinline{repeat})~---~цикл, который так же будет выполняться, пока условие истинно (\lstinline{true}), но проверка условия выполняется после прохождеия тела цикла. То есть тело цикла всегда будет выполняться хотя бы один раз, в отличие от цикла while, который может вообще не выполниться. 

\begin{lstlisting}
num = 3
repeat
  print(num)
  num = num - 1
until num == 0    
\end{lstlisting}

В результате будет выведено:
\\* 3
\\* 2
\\* 1

\subsubsection{Числовой for}
Счетный цикл или цикл со счетчиком (\lstinline{for})~---~цикл, в котором некоторая заданная переменная меняет свое значение от заданного начального значения до заданного конечного в соответсвии с указанным шагом. 

Синтаксис счетного цикла: 
\begin{lstlisting}
for var=exp1,exp2,exp3 do
  something
end
\end{lstlisting}

Действие \emph{something} будет исполняться для каждого значения управляющей переменной \emph{var} от начального значения \emph{exp1} до конечного значения \emph{exp2} с шагом \emph{exp3}. Указывать шаг \textbf{необязательно}, так как по умолчанию шаг равен 1.

\begin{lstlisting}
for var=0,6,2 do
  print(var) 
end
\end{lstlisting}

В результате будет выведено:
\\* 0
\\* 2
\\* 4
\\* 6

\emph{Замечания}:
\begin{itemize}
	\item Управляющая переменная \emph{var} является локальной, то есть видна только в пределах цикла, а в не его не существует.
	\item Если в качестве одного из \emph{exp} стоит функция, то она будет вызвана всего один раз перед началом цикла, то есть при изменении значения переменных, передаваемых в цикл, граница цикла все равно не изменится. 
	\item Не следует менять значение управляющей переменной, так как тогда поведение будет непредсказуемым. Если есть необходимость остановить цикл, лучше использовать оператор \lstinline{break}.
\end{itemize}

		   
\begin{lstlisting}
var = 3
for i = 1,10 do
  if i >= var then
    break
  else
    print(i .. "is less than 3")
  end
end
\end{lstlisting}

В результате будет выведено: 
\\* 1 is less than 3
\\* 2 is less than 3

\subsubsection{Общий for}

Совместный цикл или цикл с итератором(for)~---~цикл, который позволяет обходить все значения, которые возвращаются функцией итератора. Итератор предоставляет нам доступ к элементам коллекции(массива) и обеспечивает навигацию по ней. Говоря простым языком, совместный цикл позволяет нам "пройтись" по всем элементам массива или другого объединения, последовательно получая индексы и/или значения. 

\begin{lstlisting}
for i,v in ipairs(a) do 
  print(v) 
end
\end{lstlisting}

За один шаг цикла в \emph{i} помещается очередной индекс массива \emph{a}, а в \emph{v} значение, ассоциируемое с данным индексом. 

Стандартные функции-итераторы:
\begin{itemize}
	\item io.lines - обход строк в файле
	\item pairs - пар в массиве(таблице)
	\item string.gfind - слов в строке 
	\item и т.д.
\end{itemize}

  
\subsection{Присваивание}

Присваивание означает изменение(запись) значения переменной или поля таблицы(массива)~---~ смотри секцию~\ref{subsec:tables}.

\begin{lstlisting}
str = "Hello" .. "World"
number = number + 1
\end{lstlisting}

Lua позволяет проивзодить множественное присваивание, то есть список значений присваивается списку переменных за один шаг. Элементы обоиз списков разделяются запятыми. 

\begin{lstlisting}
str, number = "Hello" .. "World", number + 1
\end{lstlisting}

Переменной \emph{str} будет присвоено значение \emph{Hello World}, в то время как значение переменной \emph{number} увеличится на единицу. 

В Lua сначала производится оценка переменных, а затем выполняется присваивание. Благодаря этому, мы можем произвести обмен значениями переменых за один шаг

\begin{lstlisting}
 x, y = y, x                -- swap x and y
 a[i], a[j] = a[j], a[i]    -- swap a[i] and a[j]
\end{lstlisting}

Если количество переменных отлично от количества значений, то:
\begin{enumerate}
	\item Если количество переменных больше количества значений, то переменым, которым не представлены значения получат значение \emph{nil}
	\item Если количество переменных меньше количества значений, то лишние значения будут проигнорированы
\end{enumerate}

\begin{lstlisting}
    a, b, c =  1, 2
    print(a,b,c)           --> 1  2   nil
    a, b = 1, 2, 3   	   -- 3 ignores
    print(a,b)             --> 1   2
    a, b, c = "Hello"
    print(a,b,c)           --> "Hello"   nil   nil
\end{lstlisting}

\subsection{Блоки. Глобальные и локальные переменные} 

Блок является логически сгруппированным набором идущих подряд инструкций и ограничивает область видимости переменных. Блоком является любая управляющая конструкция(циклы, условные конструкции после \lstinline{then} и \lstinline{else}, функции), а также файл, в котором исполняется скрипт. Блоки могут быть вложенными. Для создания блока используется конструкция \lstinline{do}-\lstinline{end}.

\begin{lstlisting}
do
  --some instructions
end         
\end{lstlisting}

\begin{lstlisting}
str = "Hello World"      -- global
local x = 10 			-- local
\end{lstlisting}

Все переменные объявленые в lua в любом блоке являются глобальными, если они не помечены служебным словом \lstinline{local}.
\lstinline{local} указывает на то, что переменная будет локальна, то есть сущесвтует только в пределах блока, в котором она объявлена. 

\begin{lstlisting}
x = 10
i = 1  
    
while i <= x do
  local x = i*2     -- local for "while" body
  print(x)          --> 2, 4, 6, 8, ...
  i = i + 1
end
  
if i > 20 then
  local x           -- local for "then" body
  x = 20
  print(x + 2)	  --> 22
else
  print(x)         --> 10 (global)
end
    
print(x)             --> 10 (global)
\end{lstlisting}

\subsection{Таблицы}
\label{subsec:tables}

\subsubsection{Общая информация}

Таблица представляет собой ассоциативный массив. Ассоциативный массив~---~это массив, в котором индексы не обязательно должны являться числами, а могут быть представлены и другими типами(кроме \lstinline{nil}), то есть это множество пар "ключ-значение". У таблицы нет фиксированного размера, она может динамически увеличиваться. Таблица может хранить значения различных типов. Если значение поля не задано, то оно будет равно \lstinline{nil}. 

Таблицы используются для представления обычных массивов, очередей, множеств и других структур данных. В Lua таблицы являются объектами. Объект~---~это некоторая сущность, обладающая определенным состоянием и поведением, имеющая заданные свойства и методы, которые производят операции над ними. При работе с объектами, на самом деле мы манипулируем ссылками на них в памяти. Таблицы объявляются при помощи специального выражения  конструктора~---~\{\}. 

\begin{lstlisting}
table = {}
table[1] = 4
table[2] = "Hello"
table["some"] = 1
print(table[1] + table["some"])     --> 5
print(table[2] .." " .. table[1])   --> Hello 4
print(table["other"])               --> nil
\end{lstlisting}

Работая с таблицей, мы обращаемся к указателю(ссылке) на нее в виртуальном адресном пространстве.
В следующем ниже примере переменная \emph{b} будет указывать на ту же самую таблицу, что и \emph{a}.
\begin{lstlisting}
a = {}
a["x"] = 10
b = a  -- "b" refers to the same table as "a"  

print(b["x"]) --> 10
b[2] = 5
print(a[2]) --> 5
   
a = nil -- "a" no longer refers to the table
b = nil -- "b" also doesn't refer to the table, there isn't any reference to the table 
\end{lstlisting} 

Таблица существует в памяти до тех пор, пока на нее указывает хоть одна переменная, как только закончатся все ссылки на таблцу, она будет удалена, и память будут освобождена.

Lua допускает другую форму обращения к элементу таблицы, индекс которой является строкой. 

\begin{lstlisting}
a.x = 10 -- same as a["x"] = 10
\end{lstlisting}

Стоит отметить, что \emph{a.x} означает именно обращение к индексу \emph{"x"}, но никак не \emph{x}. 

Если индекс содержит специальные символы, то обращаться к индексу через оператор []:

\begin{lstlisting}
a = {}
a["this-is-my-special-key"] = "value";
\end{lstlisting}

Таблицу можно инициализировать при помощи ключей:

\begin{lstlisting}
a = {
  name = "Petr",
  surname = "Ivanov"
}

print(a.name) -- Petr
print(a.surname) -- Ivanov
\end{lstlisting}

Размер таблицы можно узнать при помощи оператора \lstinline{#}:

\begin{lstlisting}
my_table = {10, 22, 35, 47}
print(#my_table) --> 4
\end{lstlisting}

\subsubsection{Итерация элементов таблицы}

Итерацию элементов (перебор всех элементов) можно осуществить при помощи конструкции \lstinline{for .. in pairs}:

\begin{lstlisting}
a = {
  ["Blondie"] = "Good",
  ["Angel Eyes"] = "Bad",
  ["Tuco"] = "Ugly"
}

for i,v in pairs(a) do print("Person " .. i .. " is " .. v) end
\end{lstlisting}

Вывод на экран:

\begin{lstlisting}
  Person Tuco is Ugly
  Person Blondie is Good
  Person Angel Eyes is Bad
\end{lstlisting}


В данном примере в цикле \lstinline{for} в переменную \emph{i} помещаются ключи таблицы, а в \emph{v}~---~значения. 
Ключи могут быть как и числами, так и строками. Необходимо помнить, что порядок обхода элементов при использовании \lstinline{for .. in pairs} является \emph{случайным}!

Если все ключи в таблице являются числами, то можно использовать конструкцию \lstinline{for .. in ipairs}:

\begin{lstlisting}
t = { "a", "b", "c", "d" }  
for i, v in ipairs(t) do  
  print(i .. ": " .. v)   
end  
\end{lstlisting}

Результат выполнения:

\begin{lstlisting}
  1: a
  2: b
  3: c
  4: d
\end{lstlisting}

Отличие от \lstinline{for .. in pairs} в том, что ключ является целочисленным, начинается с 1, и с каждой итерацией увеличивается на 1. Если во время обхода таблицы будет встречен ключ-строка, то он будет проигнорирован, если же попадет ключ, который равен \lstinline{nil}, то обход массива будет прекращен!

\begin{lstlisting}
t = { "a", ["test"] = "f", "b", "c", ["name"] = 5, "d", nil, 6 }  
for i, v in ipairs(t) do  
  print(i .. ": " .. v)   
end  
\end{lstlisting}

Результат выполнения:

\begin{lstlisting}
  1: a
  2: b
  3: c
  4: d
\end{lstlisting}

\subsubsection{Массивы}

Массивы можно реализовать при помощи таблиц, используя в качестве ключей числа. 
У массивов нет ограничений по количеству элементов, и они ``растут'' когда это понадобится.

Пример инициализации массивов:

\begin{lstlisting}
a = {}    -- new array
for i=1, 1000 do
  a[i] = i + 2 
end
\end{lstlisting}

Массивы можно инициализировать также таким способом:

\begin{lstlisting}
squares = {1, 4, 9, 16, 25, 36, 49, 64, 81}
\end{lstlisting}

Необходимо обратить внимание, что индексация массивов в языке Lua начинаются с \textbf{1}, а не с 0!
Стандартные функции по работе с таблицами подразумевают, что массивы индексируются с 1.
Однако, при инициализации можно задать другие границы массива:

\begin{lstlisting}
a = {}
for i=-5, 5 do
  a[i] = 0
end 
\end{lstlisting}

Двумерные массивы можно реализовать двумя способами:

\begin{itemize}
	\item Создать массив из \emph{N} элементов. Каждый элемент массива - это ещё один массив размера \emph{M}:
	
\begin{lstlisting}
mt = {}          -- create the matrix
for i=1,N do
  mt[i] = {}     -- create a new row
  for j=1,M do
    mt[i][j] = 0
  end
end
\end{lstlisting}

	\item Создать \emph{одномерный} массив из $N * M$ элементов и добавлять элементы по следующему правилу (смотри 4-ую строку):

\begin{lstlisting}
mt = {}          -- create the matrix
for i=1,N do
  for j=1,M do
    mt[i*M + j] = 0
  end
end
\end{lstlisting}
	
\end{itemize}

Такими же способами можно создавать N-мерные массивы.

\subsubsection{Множества (Sets)}


При помощи таблиц в Lua можно реализовать множества, если в качестве ключа передавать необходимое значение (число или строку), 
а в качестве значения~---~\lstinline{true}. Множество~---~это структура данных, которая позволяет хранить ограниченное число значений определенного типа без определенного порядка, при этом каждое значение встречаеися ровно один раз. В программировании множество конечно. Проверять наличие элемента можно такой конструкцией: \lstinline{if set[element] then ... end}, где \emph{set}~---~множество, а \emph{element}~---~искомый элемент.

Пример множества:

\begin{lstlisting}
set = {}

for i = 2, 10, 2 do
  set[i] = true
end

for i = 1, 10 do
  if set[i] then
    print(i .. " in set")  
  end
end
\end{lstlisting}

\subsubsection{Функции для работы с таблицами}

\begin{enumerate}
	\item \lstinline{table.insert}~---~производит вставку элемента в таблицу, представляющую собой массив. В качестве аргументов предается таблица, куда будет производиться вставка, затем, может идти индекс позиции для вставки, в этом случае все остальные элементы будут сдвинуты, а затем собственно значение для вставки. 
	
\begin{lstlisting}
a = {10, 20, 30}
table.insert(a, 1, 0)     -- a will be: 0, 10, 20, 30
\end{lstlisting}

	Если индекс для вставки не указан, то элемент будет добавлен в конец.
	
	\item \lstinline{table.remove}~---~удаляет элемент с указанной позиции. Аргументами является имя таблицы и индекс элемента для удаления. Если индекс не указан, то будет удален последний элемент массива. 

\begin{lstlisting}
a = {10, 20, 30}
table.remove(a, 2)     -- a will be: 10, 30
\end{lstlisting}

	\item \lstinline{table.concat}~---~соединяет элементы массива в одну строку. Каждый элемент должен быть конвертируемым в строку.  Можно задать разделитель, который будет ставится между элементами при объединении. Так де можно задать диапазон конкатенации.
	 
\begin{lstlisting}
table.concat({ 1, 2, "three", 4, "five" }) -- 12three4five
table.concat({ 1, 2, "three", 4, "five" }, ", ") -- 1, 2, three, 4, five
table.concat({ 1, 2, "three", 4, "five" }, ", ", 2) -- 2, three, 4, five
table.concat({ 1, 2, "three", 4, "five" }, ", ", 2, 4) -- 2, three, 4
\end{lstlisting}

	\item \lstinline{table.sort}~---~сортирует элементы массива. В качестве аргументов принимает массив, который необходимо сортировать, и, что является необязательным, функцию для сравнения двух элементов, принимающую 2 параметра, и в случае, если первый должен идти первее в отсортированном массииве, она должна возвращать \emph{true}. 

Пример без функции:	
\begin{lstlisting}
array={4, 2, 1, 3, 5, 0}
table.sort(array) -- array would be 0, 1, 2, 3, 4, 5
\end{lstlisting}

Пример с функцией:
\begin{lstlisting}
array = {4, 2, 1, 3, 5, 0}
table.sort(array, function(a,b) return a>b end) -- array would be 5, 4, 3, 2, 1, 0
\end{lstlisting}
	
	\item \lstinline{table.foreach}~---~выполняет для каждого элемента таблицы заданную функцию. На каждой итерации функции передается пара \textit{ключ-значение}, соотвествующая элементу текущей итерации.
	
\begin{lstlisting}
array = { 1, 2, "three"; number="four", next="five" }
table.foreach(array, print)   
\end{lstlisting}

Результат выполнения:
\\* 1  		 1		
\\* 2   	 2
\\* 3   	 three
\\* number   four
\\* next     five

Пример с собственной функцией:
\begin{lstlisting}
table.foreach({1,"two",3,"four"}, function(k,v) print(string.rep(v,k)) end)   
\end{lstlisting}

Результат выполнения:
\\* 1
\\* twotwo
\\* 333
\\* fourfourfourfour

	\item \lstinline{table.foreachi}~---~аналогична foreachi, только в функцию подается на пара \textit{ключ-значение}, а пара \textit{индекс-значение}, то есть на каждой итерации берется только элемент, ключ которого является числом, то есть элемент, имеющий индекс. 
	

\begin{lstlisting}
array = { 1, 2, "three"; number="four", next="five" }
table.foreach(array, print)
\end{lstlisting}

Результат выполнения:
\\* 1  		 1
\\* 2   	 2
\\* 3   	 three

\end{enumerate}

\emph{Замечание:}
\lstinline{table.foreach} и \lstinline{table.foreachi} являются устаревшими в версии \emph{lua} 5.1.(depracated). Их использование является нежелательным, так как скорее всего в дальнейших версиях эта вохможность языка будет убрана. 


\subsection{Работа со строками}

Интерпретатор \emph{Lua} имеет достаточно ограниченные возможности по работе со строками. Он может создавать строки и объединять их, но извлечение подстроки, вычисление размера и т.д. представляется для него невозможным. Поэтому для удобной работы со строками в \emph{Lua} используется его стандартная библиотека для строк. Она включает множество различных функций для работы со строками. 

\begin{enumerate}
	\item \lstinline{string.len}~---~возвращает длину строки.

\begin{lstlisting}
s = "Hello"
print(string.len(s))       --> 5
\end{lstlisting} 

	\item \lstinline{string.rep}~---~возвращает строку, в которой заданная строка повторена n раз.
	
\begin{lstlisting}
s = "Hello"
print(string.rep(s, 4))       --> HelloHelloHelloHello
\end{lstlisting} 

	\item \lstinline{string.lower} и \lstinline{string.upper}~---~возвращают строку в нижнем или верхнем регистре, соотвественно. 

\begin{lstlisting}
s = "HeLlo"
print(string.lower(s))     --> hello
print(string.upper(s))     --> HELLO
\end{lstlisting} 

	\item \lstinline{string.sub}~---~возвращает подстроку, начиная с позиции i и заканчивая позицией j.Позиция может быть как положительным числом(отсчет с начала слова),  так и отрицательным(отсчет с конца). В \emph{Lua} первый символ строки имеет индекс 1 при отсчете с начала строки, при отсчете с конца строки последний символ имеет индекс -1. 
	
\begin{lstlisting}
s = "Some string here"
t = string.sub(s, 2, -2);
print(t);                        -->ome string her
\end{lstlisting} 

\emph{Замечание:}
Функция \lstinline{string.sub} не именяет саму строку, а создает новую, поэтому для получения подстроки необходимо использовать переменную, в которую будет записана эта подстрока. 

	\item \lstinline{string.char} и \lstinline{string.byte}~---~функции, которые используются для перевода числа в символьный эквивалент и наоборот.
	 Функция \lstinline{char} принимает 0 или более целых чисел, переводит каждое в символ, коду которого данное число соотвествует и возвращает строку, которая является совокупностью всех получившихся символов. 
	
\begin{lstlisting}
print(string.char(97, 98, 99, 100))       --> abcd
\end{lstlisting} 

	Функция \lstinline{string.byte} возвращает код одного символа, стоящего на i позиции. Если второй аргумент, обозначающий позиция не задан, то будет возвращен код первого символа. 
	
\begin{lstlisting}
print(string.byte("abc"))                 -->  97
print(string.byte("abc", 2))              -->  98
print(string.byte("abc", -1))     	  -->  99
\end{lstlisting}
	
	\item \lstinline{string.format}~---~функция, которая позвляет отформатировать строку, то есть создать строку заданного формата. Первым аргументом ф функцию передается стркоа формата, а затем данные, которые должны передаваться в эту строку. Строка формата состоит из обыного текста и директив(спецификаторов, модификаторов), которая контролирует то, где и как каждый следующий поданный аргумент должен располагаться в итоговой строке. Директива начинается с символа % и дальше следует символ, который указывает формат аргумента.

\emph{Спецификаторы типа:}
\begin{enumerate}
	\item \lstinline{%d}~---~целое десятичное число со знаком
	\item \lstinline{%u}~---~целое десятичное число без знаком
	\item \lstinline{%f}~---~число с плавающей запятой в виде десятичной дроби
	\item \lstinline{%o}~---~целое восьмеричное число
	\item \lstinline{%x}~---~целое шестнадцатеричное число в нижнем регистре
	\item \lstinline{%s}~---~строка
\end{enumerate}

Спецификатор ширины поля задается числом между % и спецификатором типа. Он заполняет поле вывода пробелами или нулями, обеспечивая ее минимальную ширину. Если строка или число больше минимальной ширины поля, они все равно выводятся полностью. По умолчанию в качестве заполнителя используется пробел. Если пус­тующее поле вывода необходимо заполнить нулями, перед спецификатором ширины поля следует поставить символ 0.

Модификатор точности задает точность числа с плавающей запятой. Обозначется символом "." и числом после, указывающим количество знаком после запятой. Если модификатор точности используется для целого числа, то задает минимальное количество цифр в числе и в случае недостатка из дополняет число ведущими нулями. Если используется для строки, то задает максимальное количество символов. Если строка окажется длинее, лишние символы будут отброшены. 

\begin{lstlisting}
pi = 3.14159265359
d = 13
s = "Hello"
day = 8
print(string.format("PI - %.4f, number = %.4d, today is %02d of July, string with less than 5 symbols - %.4s", pi, d, day, s))
\end{lstlisting} 

Результат выполнения:
PI - 3.1416, number = 0013, today is 08 of July, string with less than 5 symbols - Hell

	\item \lstinline{string.find}~---~функция ищет шаблон в строке, то есть ищет подстроку, соответсущую заданному паттерну. Функция возвращает два числа, индекс начала и индекс конца, или \lstinline{nil}, если совпадений обнаружено не было. Так же есть возможность передать в функцию третий параметр, задающий индекс, с которого будет начат поиск. 
	
\begin{lstlisting}
array = {}
s = 123145167
i = 0
while true do
i = string.find(s, '1', i+1)	-- find next '1'
if i== nil then
	break
end
table.insert(array, i)
end
print(table.concat(array, ","))
\end{lstlisting}

Результат выполнения:
1,4,7

	\item \lstinline{string.gsub}~---~функция, которая используется для замены посдтрок, соответвующих шаблону, на заданную строку. Так же как и другие функции со строкам она не изменяет исходную строку, а лишь возвращает новую. Функция принимает три параметра: исходную строку, шаблон и строку для замены, есть возможность передать четвертый параметр, который задает максимальное количество замен. Помимо новой строки функция так же возвращает количество замен, поэтому при помощи этой функции можно быстро подсчитать количество определенных подстрок или символов, например количество пробелов в строке. 
	
\begin{lstlisting}
s="Hello, somebody"
s=string.gsub(s, "llo", "p")
print(s) --> Help, somebody
s=string.gsub("All lla", "l", "x")
print(s) --> Axx xxa
s=string.gsub("All lla", "l", "x", 2)
print(s) --> Axx lla
s, count = string.gsub("Lua is great", " ", " ");
print(count) --> 2
\end{lstlisting}
	
	\item \lstinline{string.match}~---~аналогична \lstinline{string.find}, то есть так же ищет подстроку, подходящую под шаблон, но вместо индексов конца и начала возвращает найденный текст. 
	
\begin{lstlisting}
print(string.match("foo 123 bar", '%d%d%d')) -- %d matches a digit
\end{lstlisting}

Результат выполения:
123

\end{enumerate} 

\subsubsection{Шаблоны}
Шаблон представлет из себя строку, которая может включать в себя специальные символы, обозначающие опредеенную последовательнось обычных символов. 

\begin{enumerate}
	\item Символьный класс~---~часть шаблона, обозначающая символ из определенного множества
	
	\begin{enumerate}
	 \item .~---~любой символ
	 \item \%a~---~буквы
	 \item \%c~---~управляющие символы
	 \item \%d~---~целые числа
	 \item \%l~---~буквы в нижнем регистре
	 \item \%p~---~знаки пунктуации
	 \item \%s~---~разделители(пробел, табуляция)
	 \item \%u~---~буквы в верхнем регистре
	 \item \%w~---~буквы и цифры
	 \item \%x~---~шестнадцатеричные цифры
	\end{enumerate}
	
	Можно создать собственный класс, заключив список символов или их диапазон в []. Для указания диапазона между символами ставится знак \lstinline{-}, если же этот символ будет стоять первым символом после открывающейся квадратной скобки или последним символом перед закрывающецся квадратной скобкой, то он будет считаться обычным символом. Для создания отрицательного класса после открывающей скобки необходимо поставить символ \lstinline{^}. 
	
\begin{lstlisting}
s = "Deadline is 21.08.2016, hurry up"
date = "%d%d.%d%d.%d%d%d%d"
print(string.sub(s, string.find(s, date))) --> 21.08.2016
print(string.match("123a something", "12[34][a-z]")) --> 123a
print(string.match("124z something", "12[34][a-z]")) --> 124z
print(string.match("125y something", "12[34][a-z]")) --> nil
\end{lstlisting}
	
	\item Квантификаторы~---~определяют количество возможных появлений впереди стоящего символа
	\begin{itemize}
		\item \lstinline{*}~---~повторение впереди стоящего символа(или класса) ноль или более раз(как можно больше символов захватывается при сравнении с шаблоном~---~максимальный квантификатор)
		\item \lstinline{+}~---~повторение впереди стоящего символа(или класса) один или более раз(как можно больше символов захватывается при сравнении с шаблоном~---~максимальный квантификатор)
		\item \lstinline{-}~---~повторение впереди стоящего символа(или класса) ноль или более раз(как можно меньше символов захватывается при сравнении с шаблоном~---~минимальный квантификатор)
		\item \lstinline{?}~---~повторение впереди стоящего символа(или класса) ноль или один раз
	\end{itemize}
	
\begin{lstlisting}
print(string.match("aaabc", 'a*')) --> aaa
print(string.match("aaabc", 'a-')) --> 
print(string.match("aaabc", 'a+')) --> aaa
print(string.match("aaabc", 'a?')) --> a
\end{lstlisting}
	
	\item Запоминающие скобки позволяют отметить ту часть шаблона, которую необходимо сохранить и затем вернуть, например в функции \lstinline{string.match}.

\begin{lstlisting}
date = "26/8/2016"
var1, var2, d, m, y = string.find(date, "(%d+)/(%d+)/(%d+)")
print(d, m, y)  --> 26  8  2016
\end{lstlisting}

	\item Специальные символы:
			\begin{enumerate}
				\item \lstinline{^}~---~начало строки
				\item \lstinline{$}~---~конец строки
				\item \lstinline{%}~---~отменяет специальное значение следующего за ним символа
			\end{enumerate}

\begin{lstlisting}
print(string.match("Hello 3!, user2!", "[1-9]!")) --> 3!
print(string.match("Hello 3!, user2!", "[1-9]!$")) -->2!
print(string.match("Hello 3!, user2!", "^[1-9]!")) -->nil
\end{lstlisting}

\end{enumerate}

\subsection{Функции}
Функции являются главным механизмом абстракции выражений и утверждений в \emph{Lua}. Они могут как выполнять определенную задачу(процедура или подпрограмма), так и вычислять и возвращать значения. В первом случае функция вызывается как утверждение, во втором как выражение. 

\begin{lstlisting}
print(8*9, 9/8) --statement
a = math.sin(3) + math.cos(10) --expression
\end{lstlisting}

В обоих случаях пишется имя функции и список аргументов в круглых скобках (). Если список аргументов пустой, то скобки будут пустыми, они нужны для идентификации функции, то есть для определения, что это именно функция. Если функция имеет всего один аргумент, и он является либо строкой, либо конструктором таблиц, то скобки можно упустить.

\begin{lstlisting}
print "Hello World" -- print("Hello World")
f{x=10, y=20} -- f({x=10, y=20})
\end{lstlisting}

Также \emph{Lua} предоставляет специальный синтаксис для объектно-ориентированых вызовов~---~оператор двоеточия. Выражение \lstinline{o:foo(x)} выполняет абсолютно то же действие, что и выражение \lstinline{o.foo(o, x)}, то есть является обычным вызовом функции объекта, но в качестве первого аргумента передается объект, функция которого вызывается. 

Определение функции всегда содерджит имя этой функции, список параметров и тело, которое включает список выражений:

\begin{lstlisting}
 function sum_of_array (a)
      local sum = 0
      for i,v in ipairs(a) do
        sum = sum + v
      end
      return sum
    end
\end{lstlisting}

Параметры работают так же, как и локальные переменные, то есть они видны в пределах функции, но не доступны вне ее. Они инициализируются аргументами, которые подаются при вызове функции. Можно вызвать функцию с количеством аргументов превышающим количество возможных параметров. В случае недостатка аргументов, все оставшиеся параметры будут инициализированы \lstinline{nil}, в случае избытка, лишние будут проигнорированы.

\begin{lstlisting}
function f(a, b) 
return a or b 
end
\end{lstlisting}
CALL             PARAMETERS
       
//* f(3)             a=3, b=nil
//* f(3, 4)          a=3, b=4
//* f(3, 4, 5)       a=3, b=4   (5 is ignored)


\subsubsection{Множественные значения}
Важной особенностью \emph{Lua} является возможность возврата множественных значений из функции, в то время как во многих языках программирования функция может возвращать всего одно значение. Для возврата нескольких значений достатчоно написать их все через запятую после ключевого клова \lstinline{return}.


Функция, определяющая максимальное значение массива и его индекс:
\begin{lstlisting}
function maximum (a)
      local mi = 1          -- maximum index
      local m = a[mi]       -- maximum value
      for i,val in ipairs(a) do
        if val > m then
          mi = i
          m = val
        end
      end
      return m, mi
    end
\end{lstlisting}

Функция, которая возвращает несколько значений и вызывается в другом выражении, может вести себя по разному в зависимости от своего местоположения. Например, при множественном присваивании, если вызов функции стоит не последним значением, то тогда будет использовано только первое возвращенное значение. Если же оно стоит на последнем месте в списке, то тогда оно предоставит столько результатов, сколько необходимо.

\begin{lstlisting}
function foo2 ()
 return 'a','b' 
end

x,y,z = 10,foo2()   -- x=10, y='a', z='b'
x,y,z = foo2()    -- x='a', y='b', z=nil
x,y = foo0(), 20, 30  -- x='nil', y=20, 30 is ignored

\end{lstlisting}

Аналогичное поведение будет наблюдаться, если результат функции передается в качестве параметров в другой вызов или является значением в конструктуре таблиц.

\begin{lstlisting}
print(foo2())          -->  a   b
print(foo2(), 1)       -->  a   1
print(foo2() .. "x")   -->  ax  

a = {foo2()}         -- a = {'a', 'b'}
a = {1, foo2(), 4}   -- a[1] = 1, a[2] = 'a', a[3] = 4
\end{lstlisting}

Можно заставить вызов возвращать только одно значение, если поместить вызов функции в круглые скобки

\begin{lstlisting}
function foo (i)
 return foo2()
end

print(foo(2))     --> a  b
print((foo2()))        --> a
\end{lstlisting}

Стоит отметить, что при помещении возвращаемого значения в варажении \lstinline{return} в круглые скобки, возвращено будет только одно значение, независимо от того, сколько их на самом деле возвращалось бы. То есть \lstinline{return (f())} всегда вернет только одно значение - первое. 

\subsubsection{Переменное число параметров}

Некоторые функции в \emph{lua} могут принимать переменное число аргументов, например функция \lstinline{print}. При создании функции с переменным количеством аргументов достаточно в списке параметров указать троеточие~---~\lstinline{...}.  Когда функция будет вызвана, переданные параметры, которым не соотвествует конкретное имя аргумента, будут собраны в таблицу, к которой функия может получить доступ по имени \lstinline{arg}. Помимо самих параметров таблица \lstinline{arg} имеет дополнительное поле \lstinline{n}, которое содержит число аргументов в таблице. 

Функция, которая сохраняет свои аргументы в глобальную переменную:
\begin{lstlisting}
printResult = ""
    
    function save (...)
      for i,v in ipairs(arg) do
        printResult = printResult .. tostring(v) .. "\t"
      end
      printResult = printResult .. "\n"
    end
\end{lstlisting} 

Иногда функция может иметь некоторое число фиксированных параметров, а затем переменное число параметров. 

\begin{lstlisting}
function g (a, b, ...)
end
\end{lstlisting}

Примеры:      
\newline g(3) a=3, b=nil, arg={n=0}
\newline g(3, 4) a=3, b=4, arg={n=0}
\newline g(3, 4, 5, 8) a=3, b=4, arg={5, 8; n=2}


\subsubsection{Именованные аргументы}
Механизм параметров в \emph{Lua} является позиционным, то есть первое переданное в функцию значение будет занесено в первый параметр, второе значение во второй и т.д. Но в функциях, которые имеют много различных параметров или одинаковые по типу, но разные по типу параметры, будет удобно передавать аргументы не по позиции, а по имени параметра. В \emph{Lua} для этого достаточно написать имя функции и в фигурных скобках указать параметры с необходимым значением: 

Функция, которая переименовывает файл:
\begin{lstlisting}
rename{old="temp.lua", new="temp1.lua"}
\end{lstlisting}

Идея этого метода заключается в том, что мы сохраняем все параметры в одну таблицу, а передаем ее в качестве единственного параметра. По сути мы определеяем новую функцию, которая принимает всего один аргумент и имеет следующее тело:

\begin{lstlisting}
function rename (arg)
 return os.rename(arg.old, arg.new)
end
\end{lstlisting}

\subsubsection{Особенности}

Функции в \emph{Lua} являются объектами первого класса, то есть они обладают теми же правами, что и примитивные типы, такие как строки или числа. Функцию можно сохранить в переменную, как глобальную, так и локальную, или в таблицу. Она может быть передана в другую функцию в качестве аргумента, и может быть возвращена из другой функции.

Стоит отметить, что функции являются анонимными, то есть они не имеют имени. Когда мы говорим об имени функции, на самом деле речь идет о переменной, которая содержит функцию. 

\begin{lstlisting}
p = print -- p refers to print function
print(1)
print = math.sin -- print refers to sinus function
p(print(1))
sin = p --sin refers to print function
sin(1)
\end{lstlisting}

Результат работы функции:
\newline 1
\newline 0.8414709848079
\newline 1

Функция создается при помощи специального выражения:
\begin{lstlisting}
 function foo (x) return 2*x end
\end{lstlisting}

На самом же деле вышепредставленное выражение является всего лишь ``синтаксическим сахаром'', выражением, которое было содано специально для удобства программистов. На самом деле это то же самое, что и запись:

\begin{lstlisting}
	foo = function (x) return 2*x end
\end{lstlisting}

Можно сказать, что \lstinline{function} является типом переменной. 

Другой особенностью функций в \emph{Lua} является лексическая область видимости. Данное понятие описывает возможность использования локальных переменных функции внутри других функций, что объявлены внутри нее.

\begin{lstlisting}
function sortbygrade (names, grades)
    table.sort(names, function (n1, n2)
      return grades[n1] > grades[n2]    -- compare the grades
   end)
end
\end{lstlisting}  


Как уже упоминалось, функции являются объектами, а значит их можно задавать, например, в качестве поля таблицы. Это можно сделать тремя разными способами, которые очевидно вытекают из всего вышесказаного:

\begin{enumerate}
	\item 

\begin{lstlisting}
Lib = {}
Lib.sum = function (x,y) return x + y end
Lib.dif = function (x,y) return x - y end
\end{lstlisting}

	\item 
	
\begin{lstlisting}
Lib = {
  sum = function (x,y) return x + y end,
  dif = function (x,y) return x - y end
}
\end{lstlisting}

	\item  
	
\begin{lstlisting}
Lib = {}
function Lib.sum (x,y)
  return x + y
end
function Lib.dif (x,y)
  return x - y
end
\end{lstlisting}

\end{enumerate}
